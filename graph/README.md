#### Dijkstra算法

Dijkstra算法是典型的单源最短路径算法，计算一个节点到其他所有节点的最短路径，基本思想是以起始点为中心向外层层扩散之至终点。

设`G=(V,E)`是一个带权有向图，将图中顶点集合`V`分成两组，一组为已求出最短路的顶点集合（用`S`表示，初始时只有源点`s`一个顶点，以后每求得一条最短路径 , 就将加入到集合`S`中，直到全部顶点都加入到`S`中，算法就结束了）；另一组为其余未确定最短路的顶点集合（用`U`表示），按最短路径长度的递增次序依次把第二组的顶点加入`S`中。在加入的过程中，总保持从源点`v`到`S`中各顶点的最短路径长度不大于从源点`v`到`U`中任何顶点的最短路径长度。此外，每个顶点对应一个距离，`S`中的顶点的距离就是从`v`到此顶点的最短路径长度，`U`中的顶点的距离，是从`v`到此顶点只包括`S`中的顶点为中间顶点的当前最短路径长度。算法的步骤为：

1. 初始时，`S`只包含源点，即`S＝{v}`，`v`的距离为`0`。`U`包含除`v`外的其他顶点，即`U={其余顶点}`，若`v`与`U`中顶点`u`有边，则`<u,v>`正常有权值，若`u`不是`v`的出边邻接点，则`<u,v>`权值为∞；
2. 从`U`中选取一个距离`v`最小的顶点`k`，把`k`，加入`S`中（该选定的距离就是v到k的最短路径长度）；
3. 以`k`为新考虑的中间点，修改`U`中各顶点的距离；若从源点`v`到顶点`u`的距离（经过顶点`k`）比原来距离（不经过顶点`k`）短，则修改顶点`u`的距离值，修改后的距离值的顶点`k`的距离加上边上的权；
4. 重复步骤2和3直到所有顶点都包含在`S`中。



#### Floyd算法

解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为`O(N^3)`，空间复杂度为`O(N^2)`。Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）。

从任意节点`i`到任意节点`j`的最短路径不外乎2种可能，1是直接从`i`到`j`，2是从`i`经过若干个节点`k`到`j`。所以，我们假设`Dis(i,j)`为节点`u`到节点`v`的最短路径的距离，对于每一个节点`k`，我们检查`Dis(i,k) + Dis(k,j) < Dis(i,j)`是否成立，如果成立，证明从`i`到`k`再到`j`的路径比`i`直接到j的路径短，我们便设置`Dis(i,j) = Dis(i,k) + Dis(k,j)`，这样一来，当我们遍历完所有节点`k`，`Dis(i,j)`中记录的便是`i`到`j`的最短路径的距离。

1. 从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大；
2. 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它；
3. Floyd算法过程矩阵的计算----十字交叉法



#### 拓扑排序

拓扑排序是指



