#### Dijkstra算法

Dijkstra算法是典型的单源最短路径算法，计算一个节点到其他所有节点的最短路径，基本思想是以起始点为中心向外层层扩散之至终点。

设`G=(V,E)`是一个带权有向图，将图中顶点集合`V`分成两组，一组为已求出最短路的顶点集合（用`S`表示，初始时只有源点`s`一个顶点，以后每求得一条最短路径 , 就将加入到集合`S`中，直到全部顶点都加入到`S`中，算法就结束了）；另一组为其余未确定最短路的顶点集合（用`U`表示），按最短路径长度的递增次序依次把第二组的顶点加入`S`中。在加入的过程中，总保持从源点`v`到`S`中各顶点的最短路径长度不大于从源点`v`到`U`中任何顶点的最短路径长度。此外，每个顶点对应一个距离，`S`中的顶点的距离就是从`v`到此顶点的最短路径长度，`U`中的顶点的距离，是从`v`到此顶点只包括`S`中的顶点为中间顶点的当前最短路径长度。算法的步骤为：

1. 初始时，`S`只包含源点，即`S＝{v}`，`v`的距离为`0`。`U`包含除`v`外的其他顶点，即`U={其余顶点}`，若`v`与`U`中顶点`u`有边，则`<u,v>`正常有权值，若`u`不是`v`的出边邻接点，则`<u,v>`权值为∞；
2. 从`U`中选取一个距离`v`最小的顶点`k`，把`k`，加入`S`中（该选定的距离就是v到k的最短路径长度）；
3. 以`k`为新考虑的中间点，修改`U`中各顶点的距离；若从源点`v`到顶点`u`的距离（经过顶点`k`）比原来距离（不经过顶点`k`）短，则修改顶点`u`的距离值，修改后的距离值的顶点`k`的距离加上边上的权；
4. 重复步骤2和3直到所有顶点都包含在`S`中。



#### Floyd算法

解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为`O(N^3)`，空间复杂度为`O(N^2)`。Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）。

从任意节点`i`到任意节点`j`的最短路径不外乎2种可能，1是直接从`i`到`j`，2是从`i`经过若干个节点`k`到`j`。所以，我们假设`Dis(i,j)`为节点`u`到节点`v`的最短路径的距离，对于每一个节点`k`，我们检查`Dis(i,k) + Dis(k,j) < Dis(i,j)`是否成立，如果成立，证明从`i`到`k`再到`j`的路径比`i`直接到j的路径短，我们便设置`Dis(i,j) = Dis(i,k) + Dis(k,j)`，这样一来，当我们遍历完所有节点`k`，`Dis(i,j)`中记录的便是`i`到`j`的最短路径的距离。

1. 从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大；
2. 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它；
3. Floyd算法过程矩阵的计算----十字交叉法



#### 拓扑排序

拓扑排序是指



#### 并查集

并查集顾名思义就是有“合并集合”和“查找集合中的元素”两种操作的关于数据结构的一种算法；用集合中的某个元素来代表这个集合，该元素称为集合的`代表元`；一个集合内的所有元素组织成以代表元为根的树形结构；对于每一个元素 `parent[x]`指向`x`在树形结构上的父亲节点。如果`x`是根节点，则令`parent[x] = x`；对于查找操作，假设需要确定x所在的的集合，也就是确定集合的代表元。可以沿着parent[x]不断在树形结构中向上移动，直到到达根节点。判断两个元素是否属于同一集合，只需看它们的代表元是否相同即可。

路径压缩：为加快查找速度，查找时将`x`到根节点路径上的所有点的`parent`设为根节点。

一般来说，一个并查集一三个操作：

**初始化**：包括对所有单个的数据建立一个单独的集合（即根据题目的意思自己建立的最多可能有的集合，为下面的合并查找操作提供操作对象），在每一个单个的集合里面，有三个东西：

1. 集合所代表的数据。（这个初始值根据需要自己定义，不固定）
2. 这个集合的层次通常用rank表示（一般来说，初始化的工作之一就是将每一个集合里的rank置为0）。
3. 这个集合的类别parent（有的人也喜欢用set表示）（其实就是一个指针，用来指示这个集合属于那一类，合并过后的集合，他们的parent指向的最终值一定是相同的。）

**查找函数**：就是找到parent指针的源头，可以把函数命名为get_parent（或者find_set，这个随你喜欢，以便于理解为主）；如果集合的parent等于集合的编号（即还没有被合并或者没有同类），那么自然返回自身编号；如果不同（即经过合并操作后指针指向了源头（合并后选出的rank高的集合））那么就可以调用递归函数，如下面的代码：

```c
//查找集合i（一个元素是一个集合）的源头（递归实现）
int Find_Set(int i)
{ 
    //如果集合i的父亲是自己，说明自己就是源头，返回自己的标号
   if(set[i]==i)
       return set[i];
    //否则查找集合i的父亲的源头
    return  Find_Set(set[i]);        
}

int unifind(int a){// find the root and compress the path
    int root = a;
    //find the root
    while(root != parent[root] ){ // The parent of root is root itself.
        root = parent[root];
    }
    // compress the path
    while( a != root){
        int parentOfA = parent[a];
        parent[a] = root; // 将当前节点的父节点直接设置为父节点
        a = parentOfA;
    }
    return root;
}
```

**合并集合函数**

```c
void Union(int i,int j)
{
    i=Find_Set(i);
    j=Find_Set(j);
    if(i==j) return ;
    if(rank[i]>rank[j]) set[j]=i;
    else
    {
        if(rank[i]==rank[j]) rank[j]++;   
        set[i]=j;
    }
}
```





在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网；一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环；在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。 

#### Kruskal算法

此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。

1. 把图中的所有边按代价从小到大排序； 
2. 把图中的n个顶点看成独立的n棵树组成的森林；
3. 按权值从小到大选择边，所选的边连接的两个顶点$u_i,v_i$，应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树；
4. 直到所有顶点都在一颗树内或者有n-1条边为止。

#### Prime算法

此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。

1. 图的所有顶点集合为$V$，初始令集合$u=\{s\},v=V-u$；
2. 在两个集合$u,v$能够组成的边中，选择一条代价最小的边$(u_0,v_0)$，加入到最小生成树中，并把$v_0$并入到集合$u$中；
3. 重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。

由于不断向集合u中加点，所以最小代价边必须同步更新；需要建立一个辅助数组closedge,用来维护集合v中每个顶点与集合u中最小代价边信息。

